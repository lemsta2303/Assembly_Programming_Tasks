# Labs 2 to 5: Assembly and C Programming Tasks

## Overview

These tasks were completed in x86 32-bit assembly language, with some tasks integrating C, as part of the *Computer Architecture* course labs during my second year of Computer Science studies. Working in both languages helped deepen my understanding of how programming operates at the hardware level, enhancing my proficiency with high-level languages and enabling me to tackle more complex programming challenges effectively.

### Lab 2: ASCII to UTF-16 Conversion with Emoji Replacement
This task involved converting Polish ASCII characters to Unicode UTF-16 and replacing specific sequences (e.g., “gęś”) with emoji. I learned about text encoding and memory manipulation, gaining a better understanding of character handling and representation at a low level.

### Lab 3: Decimal to Custom Base Conversion and Precision Control
This program reads an integer in base 10 from user input, converts it to a custom base (such as base 12), and displays it with specified precision. Working with custom number bases, input processing, and floating-point arithmetic strengthened my grasp of precision handling and complex number operations.

### Lab 4: Fibonacci Sequence Calculation in Assembly and C
Using both assembly and C, I created a recursive function to compute Fibonacci numbers with a limit on recursion depth. Combining C for user interaction with assembly for calculations taught me to manage stack memory and recursion effectively.

### Lab 5: Time Dilation Calculation and Array Comparison
In this lab, I implemented a time dilation calculation based on special relativity formulas, as well as a function to compare two arrays and store the maximum values at each index. These tasks provided practical experience in handling complex mathematical expressions and array manipulation directly with CPU registers.

## Learning Outcomes
These projects taught me to work effectively with assembly and C, especially in managing memory and CPU resources directly. This hands-on experience has given me a deeper understanding of programming fundamentals, making it easier to approach advanced features in high-level languages and optimize performance in data-intensive tasks.